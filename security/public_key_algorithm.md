# 公钥加密算法
原文地址:[http://blog.csdn.net/yuxiaohen/article/details/47779967](http://blog.csdn.net/yuxiaohen/article/details/47779967)

公钥加密算法又称非对称加密算法，围绕这一算法延伸出很多东西，比如：公私密钥对，密钥交换，身份验证，证书，签名。。。



## 密钥交换
严格来说是公钥交换。（在公钥加密系统中，私钥是一直只会由所有者持有的，而公钥是可以分发或者交换的）
假设现在Alice和Bob要使用公钥加密系统通信，那他们可以这样进行：

1. Alice将公钥给Bob
2. Bob将公钥回给Alice
3. Alice使用Bob的公钥加密一串信息，发给Bob
4. Bob收到加密的信息，使用自己的私钥解密
5. Bob使用Alice的公钥加密一串信息，回给Alice
6. Alice收到加密的信息，使用自己的私钥解密
然后一直这样来往通信。其中1)、2)过程我们称为密钥交换



##  证书
为了防止这种中间人攻击我们需要引入一种叫证书的玩意，证书可以用来鉴别一个通信方的身份，即可以用来进行身份验证。
我们先看看证书是个什么玩意：证书是用来标识一个公钥的所有者身份信息的。
证书中含有一段签发机构的签名（详情请看X509），所以证书是无法篡改的，值得注意的是证书中是包含有公钥的。在身份验证中，如果Alice和Bob拥有证书，那他们就可以交换证书，而不只是公钥，这样坏人就没法篡改消息了。
我们来看看这个过程：

1. 当Alice将cert_A给Bob时，被坏人M拦截，但M无计可施，他无法篡改这个证书，他只能原封不动地把cert_A转给Bob
2. 然后Bob把cert_B发给Alice，被M拦截，但M无计可施，他无法篡改这个证书，他只能原封不动地把cert_B转给Alice
3. Alice收到cert_B，经过一番分析，确定这确实Bob的证书，然后就欣然接受了。之后就用cert_B加密消息，发给Bob
4. 坏人M拦截到Alice用cert_B加密的消息，但他无计可施，他无法解开这个密文，于是他只得把密文原封不动转给Bob
5. 同理Bob回给Alice的消息，坏人M也无法篡改



## 签名
如果坏人M一不小心得到了Bob或者Alice的证书，那他就可以冒充一方了。那如何应对这种情况呢？（有没有感觉一环套一环）
聪明又机智的人类将签名用到了公钥加密通信上，我们来看看签名的概念：将一段信息使用私钥加密，即是签名。嗯。。是的，你没看错，签名就是私钥加密的密文
这种密文为何称为签名？因为能解开这段密文的公钥可以知道这段密文只能是由私钥所有者加密发出的。学名叫做不可抵赖(否认)性。
于是Alice或者Bob在发出消息前，对消息做md5/sha1之类的摘要算法，然后将摘要使用私钥加密就形成了这段消息的签名，最后将消息和签名一起发出去。接收者将签名解密之后，对消息做摘要算法，对比即可知消息未经篡改，且知道消息的确切发送者。