# CPU Cache和内存一致性

原文地址：[http://www.cnblogs.com/tonyluis/p/5454673.html](http://www.cnblogs.com/tonyluis/p/5454673.html)
　　

计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在SRAM（物理内存）当中的，由于CPU执行速度很快，而从内存读取数 据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度,因此在CPU里面就有了一级、二级Cache（DRAM）。也就是，当程序在运行过程中，会将运算需要的数据从RAM复制一份到Cache中，那么CPU进行计算时就可以直接从它的Cache读数据和向其写入数据，当运算结束之后，再将Cache中的数据刷新到物理内存当中。对于一个运算：i++;

　　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程 运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2，但最后的结果有可能是1。

　　 这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。

　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。

　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：

　　1. 通过在总线加LOCK#锁的方式

　	2. 通过缓存一致性协议

　　这2种方式都是硬件层面上提供的方式。

　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对 总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变 量，然后进行相应的操作。这样就解决了缓存不一致的问题。

　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。

　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其 他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量 的缓存行是无效的，那么它就会从内存重新读取。
　　
　　
### 参考资料
[ 聊聊cpu内存一致性](http://blog.csdn.net/yanyan19880509/article/details/52319558)

[缓存一致性（Cache Coherency）入门](http://www.infoq.com/cn/articles/cache-coherency-primer/)